# ìµœë‹¨ê²½ë¡œ - íŠ¹ì • ì§€ì ê¹Œì§€ ê°€ì¥ ë¹ ë¥´ê²Œ ë„ë‹¬í•˜ëŠ” ë°©ë²•
> ê·¸ë˜í”„(ë…¸ë“œ-ê°„ì„ )ìœ¼ë¡œ í‘œí˜„  
> ê·¸ë¦¬ë”” + ë‹¤ì´ë‚˜ë¯¹í”„ë¡œê·¸ë˜ë°  
## 1. ë‹¤ìµìŠ¤íŠ¸ë¼ Dijkstra
- í•œì§€ì ~>íŠ¹ì •ì§€ì  ê¹Œì§€ ìµœë‹¨ê²½ë¡œ / ê·¸ë¦¬ë””  
> graph=[ [(@, @), ()], [(), ...], ... ] ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë°©ì‹: ê° ë…¸ë“œì— ì—°ê²°ë˜ì–´ ìˆëŠ” (ë…¸ë“œ,ê±°ë¦¬) ì •ë³´  
> visited = [True/False]*(N+1) : ë°©ë¬¸í•œì  ìˆëŠ”ì§€ ì²´í¬ // ë°©ë²•2ì—ì„œëŠ” heapq,distanceë¹„êµë¡œ ê°€ëŠ¥í•˜ë¯€ë¡œ í•„ìš”x  
> distance = [INF]*(N+1) : ìµœë‹¨ê±°ë¦¬ í…Œì´ë¸”  
### ë°©ë²•1) ìµœë‹¨ê±°ë¦¬ ì„ í˜•íƒìƒ‰
> ê°„ë‹¨. but ì„±ëŠ¥ ë‚®  
> O(V^2) / V:ë…¸ë“œì˜ ê°œìˆ˜ ê°€ **10000ê°œ ë„˜ì–´ê°€ë©´ ëª»ì”€->ë°©ë²•2ì‚¬ìš©**  
### ë°©ë²•2) ìµœë‹¨ê±°ë¦¬ **Heapí™**ì— ë„£ì–´ì‚¬ìš© - ìš°ì„ ìˆœìœ„í  (ê±°ë¦¬:@ , ë…¸ë“œë²ˆí˜¸:@)
- ì¸ì ‘ë¦¬ìŠ¤íŠ¸[ [(),()],[(),()] ]ë°©ì‹
> ìš°ì„ ìˆœìœ„í == ìµœì†Œí™ // ìµœëŒ€í™:ìš°ì„ ìˆœìœ„(ê±°ë¦¬)ê°’ì— -ìŒìˆ˜ë¶€í˜¸ ë¶™ì—¬ì„œ ë„£ê¸°  
> heapq <- ë°ì´í„°ë„£ì„ ë•Œ **ì²«ë²ˆì§¸ì›ì†Œ** ê¸°ì¤€ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ì„ ì •(ê±°ë¦¬)  
#### heapq.heappush([Q], (ìµœë‹¨ê±°ë¦¬ , ê°ˆ ë…¸ë“œë²ˆí˜¸) )   #heappush(íì—, (ë„£ì„ë‚´ìš©))
#### heapq.heappop(Q)  #í•­ìƒ ê°€ì¥ìš°ì„ ìˆœìœ„ ë‚˜ì˜´
> ê°œì„ ëœ.  
> O(ElogV) / E:ê°„ì„ ê°¯ìˆ˜,V:ë…¸ë“œê°¯ìˆ˜  
```python
import sys
input = sys.stdin.readline
INF = int(1e9)

import heapq

V, E = map(int, input().split())
K = int(input()) #ì‹œì‘ì •ì ë²ˆí˜¸

distance = [INF]*(V+1)
gragh = [[] for i in range(V+1)]

for _ in range(E):
  u, v, w = map(int, input().split())
  gragh[u].append((v, w))

def dijkstra(K):
  q=[]
  heapq.heappush(q, (0, K))
  distance[K] = 0

  while q:
    dist, now = heapq.heappop(q)
    if distance[now] < dist:
      continue

    for tu in gragh[now]:
      cost = dist + tu[1]
      if cost < distance[tu[0]]:
        distance[tu[0]] = cost
        heapq.heappush(q, (cost, tu[0]))

dijkstra(K)

#ì¶œë ¥
for i in range(1, V+1):
  print("INF" if distance[i]==INF else distance[i])
```

***
## 2. í”Œë¡œì´ë“œ-ì›Œì…œ Floyd-Warshall
- ëª¨ë“ ì§€ì ~>ë‹¤ë¥¸ëª¨ë“ ì§€ì  ê¹Œì§€ ìµœë‹¨ê²½ë¡œ / DP
- ì¸ì ‘í–‰ë ¬(2ì°¨ì›í–‰ë ¬)[ [...]/[...]/ ]ë°©ì‹
> O(N^3) / Në…¸ë“œì˜ ê°¯ìˆ˜ê°€ ì ì„ë•Œ ì‚¬ìš©  
> distance =[[]] 2ì°¨ì›ë°°ì—´  
> forë²”ìœ„ëª¨ë‘ 1~V+1
> ex)1ë²ˆë…¸ë“œí™•ì¸> distance[A][B] > distance[A][1] + distance[1][B] ì´ë©´ ê°±ì‹   
>   > ab = min(ab, ak+kb)  
>   > ì´ë•Œ A,BëŠ” 1ë¹¼ê³  ë‚˜ë¨¸ì§€ ë…¸ë“œë“¤ ì¤‘ 2ê°œì”© ë½‘ëŠ”ê²ƒ
```python
INF = int(1e9)
V, E = map(int, input().split())

graph = [[INF]*(V+1) for _ in range(V+1)] #ğŸŒŸ[[INF]*(V+1)]*(V+1) í‹€ë¦¼!
for i in range(1, V+1): #ìê¸°ìì‹ ì€ ë¹„ìš©0
    graph[i][i] = 0
for _ in range(E): #ê°„ì„ ì •ë³´ì…ë ¥ aì—ì„œbë¡œê°€ëŠ” ë¹„ìš©c
    a,b,c = map(int, input().split())
    graph[a][b] = c

for k in range(1, V+1):
    for a in range(1, V+1):
        for b in range(1, V+1):
            graph[a][b] = min(graph[a][b], graph[a][k]+graph[k][b])

#ì¶œë ¥
for a in range(1, V+1):
    for b in range(1, V+1):
        print("INF" if graph[a][b]==INF else graph[a][b], end=" ")
    print()
```